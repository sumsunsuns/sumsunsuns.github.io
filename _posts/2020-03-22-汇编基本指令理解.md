---
layout:     post
title:     汇编语言基本指令
subtitle:   
date:       2020-03-22
author:     SGQ
header-img: img/post-sgq-20200319.jpg
catalog: true
tags:
    - 汇编语言
    - 二进制
    - 
    - 
---


##  数据传送指令（movl）


|     |   movl | a    |  b|  C语言表示   |
| --- | --- | --- | --- | --- |
|     | movl    |  Imm   |  Reg   |     |
| 例：    |   movl  |  $0x4   |   %eax  |  temp = 0x4   |
|     |  movl    | Imm    |    Mem     |     |
|    例：  |  movl    |    $-147  |   (%eax)  | * p = -147   |
|     |  movl     |   Reg   |    Reg     |     |
|   例：   |   movl   |  %eax   |  %edx   |   temp1 = temp2  |
|     |   movl   |    Reg  |   Mem   |     |
|   例：   |  movl    |  $eax   |  (%edx)   |  * p = temp   |
|     |   movl   |   Mem   |    Reg  |     |
|    例：  |    movl  |   (%eax)   | %edx     |   temp = * p  |

   movl   Imm   Reg      
示例：movl      $0x4,%eax       C语言表示：temp = 0x4

movl       Imm        Mem     
示例：movl      $-147,(%eax)   C语言表示：*p = -147

movl       Reg       Reg      
示例：movl      %eax,%edx       C语言表示：temp1 = temp2

movl       Reg       Mem     
示例：movl      $eax,(%edx)     C语言表示：*p = temp

movl      Mem     Reg      
示例：movl      (%eax),%edx     C语言表示：temp = *p

其中：
` Imm`表示操作数，`Reg`表示寄存器，`Mem`表示存储器，
 `(%eax)`表示%eax寄存器的内存地址。

注意：不能两个操作数都为内存地址；

总结：

* movl     %eax,     %ebx       意思是把32位的EAX寄存器值传送给32为的EBX寄存器值。<br>
* 其中%eax可理解成c语言的一个变量temp，(%eax)这种形式的可理解成一个指针变量*p。<br>
* 若遇到8(%ebp) ，可理解地址[ebp+8],%ebp表示起始地址，8可理解为偏移量。<br>
* 指令格式多采用小写， 寄存器名的前面加”%”前缀，立即数前加”$”前缀。<br>
* 很多指令带后缀（如上面代码中的 movl,addl中的l就是后缀），用来表示指令访问的操作数的宽度。对于32位的机器，后缀”b”表示8位，”w”表示16位，”l”表示32位。<br>

## cmp指令与jmp指令

### cmp指令
* cmpl b, a
* 相当于计算a-b，但并不保存结果
* 主要是为了设置标志寄存器的标志位
* 比如如果a==b，则ZF被设置
### jmp：无条件跳转
### jz/jnz：如果a==b/a!=b则跳转
* je 或jz 若相等则跳转(机器码74 或0F84)

## call指令与ret指令
* call指令：保存现场(返回地址，标志寄存等 )并跳转。
* ret指令：得到返回地址并返回。类似于return 。
## sub指令
* 比如： sub     $0x10,%esp  <br>表示 为esp分配了16个字节空间. 可理解为c语言中的 int a ；进行初始化。
##

```x86asm
      
        sub  $0x1c,%esp

        mov    $0x804a204, 0x4(%esp)
        mov    0x20(%esp), %eax
        mov    %eax,     (%esp)
     	call   80490da   <strings_not_equal>
        test   %eax,     %eax
        je     8048bb0   <phase_1+0x20>
      	call    80491e5   <explode_bomb>
        add    $0x1c,     %esp
        ret    
		
```

080490da <strings_not_equal>:
                	push   %edi
               	push   %esi
                	push   %ebx
          	sub    $0x4,%esp
        	mov    0x14(%esp),%ebx
        	mov    0x18(%esp),%esi
          	mov    %ebx,(%esp)
    	call   80490bb <string_length>
              	mov    %eax,%edi
         	mov    %esi,(%esp)
    	call   80490bb <string_length>
     	mov    $0x1,%edx
             	cmp    %eax,%edi
            	jne    804913d <strings_not_equal+0x63>
          	movzbl (%ebx),%eax
             	test   %al,%al
           	je     804912a <strings_not_equal+0x50>
          	cmp    (%esi),%al
           	je     8049116 <strings_not_equal+0x3c>
                	xchg   %ax,%ax
              	jmp    8049131 <strings_not_equal+0x57>
           	cmp    (%esi),%al
             	jne    8049138 <strings_not_equal+0x5e>
          	add    $0x1,%ebx
           	add    $0x1,%esi
            	movzbl (%ebx),%eax
              	test   %al,%al
             	jne    8049112 <strings_not_equal+0x38>
      	mov    $0x0,%edx
              	jmp    804913d <strings_not_equal+0x63>
      	mov    $0x0,%edx
               	jmp    804913d <strings_not_equal+0x63>
    	mov    $0x1,%edx
              	jmp    804913d <strings_not_equal+0x63>
      	mov    $0x1,%edx
              	mov    %edx,%eax
          	add    $0x4,%esp
                   	pop    %ebx
                  	pop    %esi
                	pop    %edi
                  	ret    



